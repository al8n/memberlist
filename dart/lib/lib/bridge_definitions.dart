// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.75.2.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'bridge_generated.io.dart' if (dart.library.html) 'bridge_generated.web.dart';
import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';

abstract class ShowbizDart {
  Future<Options> lanStaticMethodOptions({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLanStaticMethodOptionsConstMeta;

  Future<Options> wanStaticMethodOptions({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kWanStaticMethodOptionsConstMeta;

  Future<Options> localStaticMethodOptions({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLocalStaticMethodOptionsConstMeta;
}

class Options {
  final ShowbizDart bridge;

  /// The name of this node. This must be unique in the cluster.
  String name;

  /// Label is an optional set of bytes to include on the outside of each
  /// packet and stream.
  ///
  /// If gossip encryption is enabled and this is set it is treated as GCM
  /// authenticated data.
  String label;

  /// Skips the check that inbound packets and gossip
  /// streams need to be label prefixed.
  bool skipInboundLabelCheck;

  /// Configuration related to what address to bind to and ports to
  /// listen on. The port is used for both UDP and TCP gossip. It is
  /// assumed other nodes are running on this port, but they do not need
  /// to. Default is `0.0.0.0:7946`.
  String bindAddr;

  /// Configuration related to what address to advertise to other
  /// cluster members. Used for nat traversal.
  String? advertiseAddr;

  /// The configured protocol version that we
  /// will _speak_. This must be between [`MIN_PROTOCOL_VERSION`] and
  /// [`MAX_PROTOCOL_VERSION`].
  int protocolVersion;

  /// The timeout for establishing a stream connection with
  /// a remote node for a full state sync, and for stream read and write
  /// operations. This is a legacy name for backwards compatibility, but
  /// should really be called StreamDurationout now that we have generalized
  /// the transport.
  Duration tcpTimeout;

  /// The number of nodes that will be asked to perform
  /// an indirect probe of a node in the case a direct probe fails. Memberlist
  /// waits for an ack from any single indirect node, so increasing this
  /// number will increase the likelihood that an indirect probe will succeed
  /// at the expense of bandwidth.
  int indirectChecks;

  /// The multiplier for the number of retransmissions
  /// that are attempted for messages broadcasted over gossip. The actual
  /// count of retransmissions is calculated using the formula:
  ///
  ///   `retransmits = retransmit_mult * log(N+1)`
  ///
  /// This allows the retransmits to scale properly with cluster size. The
  /// higher the multiplier, the more likely a failed broadcast is to converge
  /// at the expense of increased bandwidth.
  int retransmitMult;

  /// The multiplier for determining the time an
  /// inaccessible node is considered suspect before declaring it dead.
  /// The actual timeout is calculated using the formula:
  ///
  ///   `suspicion_timeout = suspicion_mult * log(N+1) * probe_interval`
  ///
  /// This allows the timeout to scale properly with expected propagation
  /// delay with a larger cluster size. The higher the multiplier, the longer
  /// an inaccessible node is considered part of the cluster before declaring
  /// it dead, giving that suspect node more time to refute if it is indeed
  /// still alive.
  int suspicionMult;

  /// The multiplier applied to the
  /// `suspicion_timeout` used as an upper bound on detection time. This max
  /// timeout is calculated using the formula:
  ///
  /// `suspicion_max_timeout = suspicion_max_timeout_mult * suspicion_timeout`
  ///
  /// If everything is working properly, confirmations from other nodes will
  /// accelerate suspicion timers in a manner which will cause the timeout
  /// to reach the base SuspicionDurationout before that elapses, so this value
  /// will typically only come into play if a node is experiencing issues
  /// communicating with other nodes. It should be set to a something fairly
  /// large so that a node having problems will have a lot of chances to
  /// recover before falsely declaring other nodes as failed, but short
  /// enough for a legitimately isolated node to still make progress marking
  /// nodes failed in a reasonable amount of time.
  int suspicionMaxTimeoutMult;

  /// The interval between complete state syncs.
  /// Complete state syncs are done with a single node over TCP and are
  /// quite expensive relative to standard gossiped messages. Setting this
  /// to zero will disable state push/pull syncs completely.
  ///
  /// Setting this interval lower (more frequent) will increase convergence
  /// speeds across larger clusters at the expense of increased bandwidth
  /// usage.
  Duration pushPullInterval;

  /// The interval between random node probes. Setting
  /// this lower (more frequent) will cause the memberlist cluster to detect
  /// failed nodes more quickly at the expense of increased bandwidth usage
  Duration probeInterval;

  /// The timeout to wait for an ack from a probed node
  /// before assuming it is unhealthy. This should be set to 99-percentile
  /// of RTT (round-trip time) on your network.
  Duration probeTimeout;

  /// Set this field will turn off the fallback TCP pings that are attempted
  /// if the direct UDP ping fails. These get pipelined along with the
  /// indirect UDP pings.
  bool disableTcpPings;

  /// Increase the probe interval if the node
  /// becomes aware that it might be degraded and not meeting the soft real
  /// time requirements to reliably probe other nodes.
  int awarenessMaxMultiplier;

  /// The interval between sending messages that need
  /// to be gossiped that haven't been able to piggyback on probing messages.
  /// If this is set to zero, non-piggyback gossip is disabled. By lowering
  /// this value (more frequent) gossip messages are propagated across
  /// the cluster more quickly at the expense of increased bandwidth.
  Duration gossipInterval;

  /// The number of random nodes to send gossip messages to
  /// per `gossip_interval`. Increasing this number causes the gossip messages
  /// to propagate across the cluster more quickly at the expense of
  /// increased bandwidth.
  int gossipNodes;

  /// The interval after which a node has died that
  /// we will still try to gossip to it. This gives it a chance to refute.
  Duration gossipToTheDeadTime;

  /// Controls whether to enforce encryption for incoming
  /// gossip. It is used for upshifting from unencrypted to encrypted gossip on
  /// a running cluster.
  bool gossipVerifyIncoming;

  /// Controls whether to enforce encryption for outgoing
  /// gossip. It is used for upshifting from unencrypted to encrypted gossip on
  /// a running cluster.
  bool gossipVerifyOutgoing;

  /// Used to control message compression. This can
  /// be used to reduce bandwidth usage at the cost of slightly more CPU
  /// utilization. This is only available starting at protocol version 1.
  bool enableCompression;

  /// Used to initialize the primary encryption key in a keyring.
  /// The primary encryption key is the only key used to encrypt messages and
  /// the first key used while attempting to decrypt messages. Providing a
  /// value for this primary key will enable message-level encryption and
  /// verification, and automatically install the key onto the keyring.
  /// The value should be either 16, 24, or 32 bytes to select AES-128,
  /// AES-192, or AES-256.
  Uint8List? secretKey;

  /// Used to guarantee protocol-compatibility
  /// for any custom messages that the delegate might do (broadcasts,
  /// local/remote state, etc.). If you don't set these, then the protocol
  /// versions will just be zero, and version compliance won't be done.
  int delegateProtocolVersion;

  /// Used to guarantee protocol-compatibility
  /// for any custom messages that the delegate might do (broadcasts,
  /// local/remote state, etc.). If you don't set these, then the protocol
  /// versions will just be zero, and version compliance won't be done.
  int delegateProtocolMin;

  /// Used to guarantee protocol-compatibility
  /// for any custom messages that the delegate might do (broadcasts,
  /// local/remote state, etc.). If you don't set these, then the protocol
  /// versions will just be zero, and version compliance won't be done.
  int delegateProtocolMax;

  /// Points to the system's DNS config file, usually located
  /// at `/etc/resolv.conf`. It can be overridden via config for easier testing.
  String dnsConfigPath;

  /// Size of Memberlist's internal channel which handles UDP messages. The
  /// size of this determines the size of the queue which Memberlist will keep
  /// while UDP messages are handled.
  int handoffQueueDepth;

  /// Maximum number of bytes that memberlist will put in a packet (this
  /// will be for UDP packets by default with a NetTransport). A safe value
  /// for this is typically 1400 bytes (which is the default). However,
  /// depending on your network's MTU (Maximum Transmission Unit) you may
  /// be able to increase this to get more content into each gossip packet.
  int packetBufferSize;

  /// Controls the time before a dead node's name can be
  /// reclaimed by one with a different address or port. By default, this is 0,
  /// meaning nodes cannot be reclaimed this way.
  Duration deadNodeReclaimTime;

  /// Controls if the name of a node is required when sending
  /// a message to that node.
  bool requireNodeNames;

  /// If [`None`], allow any connection (default), otherwise specify all networks
  /// allowed to connect (you must specify IPv6/IPv4 separately)
  /// Using an empty Vec will block all connections.
  List<String>? allowedCidrs;

  /// The interval at which we check the message
  /// queue to apply the warning and max depth.
  Duration queueCheckInterval;

  Options({
    required this.bridge,
    required this.name,
    this.label = r"",
    this.skipInboundLabelCheck = false,
    this.bindAddr = r"0.0.0.0:7946",
    this.advertiseAddr,
    this.protocolVersion = 0,
    required this.tcpTimeout,
    this.indirectChecks = 3,
    this.retransmitMult = 4,
    this.suspicionMult = 4,
    this.suspicionMaxTimeoutMult = 6,
    required this.pushPullInterval,
    required this.probeInterval,
    required this.probeTimeout,
    this.disableTcpPings = false,
    this.awarenessMaxMultiplier = 8,
    required this.gossipInterval,
    this.gossipNodes = 3,
    required this.gossipToTheDeadTime,
    this.gossipVerifyIncoming = true,
    this.gossipVerifyOutgoing = true,
    this.enableCompression = true,
    this.secretKey,
    this.delegateProtocolVersion = 0,
    this.delegateProtocolMin = 0,
    this.delegateProtocolMax = 0,
    this.dnsConfigPath = r"/etc/resolv.conf",
    this.handoffQueueDepth = 1024,
    this.packetBufferSize = 1400,
    required this.deadNodeReclaimTime,
    this.requireNodeNames = false,
    this.allowedCidrs,
    required this.queueCheckInterval,
  });

  static Future<Options> lan({required ShowbizDart bridge, dynamic hint}) => bridge.lanStaticMethodOptions(hint: hint);

  static Future<Options> wan({required ShowbizDart bridge, dynamic hint}) => bridge.wanStaticMethodOptions(hint: hint);

  static Future<Options> local({required ShowbizDart bridge, dynamic hint}) =>
      bridge.localStaticMethodOptions(hint: hint);
}
